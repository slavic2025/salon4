// src/features/unavailability/actions.ts
'use server'

import { revalidatePath } from 'next/cache'
import { z } from 'zod'

import {
  UNAVAILABILITY_CAUSES,
  UNAVAILABILITY_ERROR_MESSAGES,
  UNAVAILABILITY_VALIDATION_MESSAGES,
} from '@/core/domains/unavailability/unavailability.constants'
import { createUnavailabilityRepository } from '@/core/domains/unavailability/unavailability.repository'
import { createUnavailabilityService } from '@/core/domains/unavailability/unavailability.service'
import {
  CreateUnavailabilityActionSchema,
  UpdateUnavailabilityActionSchema,
} from '@/core/domains/unavailability/unavailability.types'
import { db } from '@/db'
import { APP_ROUTES } from '@/lib/constants'
import { createLogger } from '@/lib/logger'
import { ensureUserIsStylist } from '@/lib/route-protection'
import { executeSafeAction } from '@/lib/safe-action'

/**
 * Logger pentru domeniul unavailability
 */
const logger = createLogger('unavailability')

/**
 * Instanțiem serviciul o singură dată la nivel de modul.
 * Acest lucru este eficient și simplifică corpul acțiunilor.
 */
const unavailabilityService = createUnavailabilityService(createUnavailabilityRepository(db))

/**
 * FACTORY FUNCTION: Creează o acțiune sigură care permite unui stylist să-și gestioneze propriile indisponibilități.
 * Încorporează validarea, autorizarea, execuția, gestionarea erorilor și revalidarea.
 *
 * @param schema - Schema Zod pentru validarea datelor de intrare.
 * @param actionLogic - Funcția care conține logica de business specifică.
 * @returns O Server Action completă și sigură.
 */
function createStylistUnavailabilityAction<T extends z.ZodType<any, any, any>>(
  schema: T,
  actionLogic: (payload: z.infer<T>, userId: string) => Promise<any>,
) {
  return (payload: z.infer<T>) => {
    return executeSafeAction(schema, payload, async (validatedPayload) => {
      const user = await ensureUserIsStylist()

      try {
        const result = await actionLogic(validatedPayload, user.id)
        revalidatePath(APP_ROUTES.STYLIST_UNAVAILABILITY)
        logger.info('Acțiune unavailability executată cu succes', {
          userId: user.id,
          action: 'stylist-unavailability',
        })
        return { data: result }
      } catch (error) {
        logger.error('Eroare în acțiunea unavailability', {
          error,
          userId: user.id,
          action: 'stylist-unavailability',
        })
        return { serverError: UNAVAILABILITY_ERROR_MESSAGES.CREATION_FAILED }
      }
    })
  }
}

// --- STYLIST UNAVAILABILITY SERVER ACTIONS ---

export const createUnavailabilityStylistAction = createStylistUnavailabilityAction(
  CreateUnavailabilityActionSchema,
  async (data, userId: string) => {
    // Enforțăm că stylistul poate crea doar pentru el însuși
    const actionData = { ...data, stylistId: userId }
    return await unavailabilityService.createUnavailability(actionData)
  },
)

export const updateUnavailabilityStylistAction = async (id: string, payload: unknown) => {
  return executeSafeAction(UpdateUnavailabilityActionSchema, payload as any, async (data) => {
    const user = await ensureUserIsStylist()

    try {
      // Verificăm că indisponibilitatea există și aparține stylistului
      const existing = await unavailabilityService.getUnavailabilityById(id)
      if (!existing || existing.stylistId !== user.id) {
        return { serverError: UNAVAILABILITY_ERROR_MESSAGES.UNAUTHORIZED }
      }

      const result = await unavailabilityService.updateUnavailability(id, data)
      revalidatePath(APP_ROUTES.STYLIST_UNAVAILABILITY)
      logger.info('Actualizare unavailability cu succes', {
        unavailabilityId: id,
        userId: user.id,
        action: 'update-unavailability',
      })
      return { data: result }
    } catch (error) {
      logger.error('Eroare la actualizarea unavailability', {
        error,
        unavailabilityId: id,
        userId: user.id,
        action: 'update-unavailability',
      })
      return { serverError: UNAVAILABILITY_ERROR_MESSAGES.UPDATE_FAILED }
    }
  })
}

export const deleteUnavailabilityStylistAction = async (id: string) => {
  try {
    const user = await ensureUserIsStylist()

    // Verificăm că indisponibilitatea există și aparține stylistului
    const existing = await unavailabilityService.getUnavailabilityById(id)
    if (!existing || existing.stylistId !== user.id) {
      return {
        success: false,
        error: UNAVAILABILITY_ERROR_MESSAGES.UNAUTHORIZED,
      }
    }

    const success = await unavailabilityService.deleteUnavailability(id)
    if (success) {
      revalidatePath(APP_ROUTES.STYLIST_UNAVAILABILITY)
      logger.info('Ștergere unavailability cu succes', {
        unavailabilityId: id,
        userId: user.id,
        action: 'delete-unavailability',
      })
      return { success: true }
    } else {
      logger.warn('Ștergere unavailability eșuată', {
        unavailabilityId: id,
        userId: user.id,
        action: 'delete-unavailability',
      })
      return { success: false, error: UNAVAILABILITY_ERROR_MESSAGES.DELETE_FAILED }
    }
  } catch (error) {
    logger.error('Eroare la ștergerea unavailability', {
      error,
      unavailabilityId: id,
      userId: user.id,
      action: 'delete-unavailability',
    })
    return {
      success: false,
      error: error instanceof Error ? error.message : UNAVAILABILITY_ERROR_MESSAGES.DELETE_FAILED,
    }
  }
}

export const createBulkUnavailabilityStylistAction = async (payload: {
  stylistId: string
  dates: string[]
  startTime?: string | null
  endTime?: string | null
  cause: (typeof UNAVAILABILITY_CAUSES)[keyof typeof UNAVAILABILITY_CAUSES]
  allDay: boolean
  description?: string | null
}) => {
  try {
    const user = await ensureUserIsStylist()

    // Enforțăm că stylistul poate crea doar pentru el însuși
    if (payload.stylistId !== user.id) {
      return {
        success: false,
        error: UNAVAILABILITY_ERROR_MESSAGES.UNAUTHORIZED,
      }
    }

    if (!payload.dates?.length) {
      return {
        success: false,
        error: UNAVAILABILITY_VALIDATION_MESSAGES.DATE_REQUIRED,
      }
    }

    const results = []
    const errors = []

    // Creăm fiecare indisponibilitate individual
    for (const date of payload.dates) {
      try {
        const unavailabilityData = {
          stylistId: payload.stylistId,
          date,
          startTime: payload.allDay ? null : payload.startTime,
          endTime: payload.allDay ? null : payload.endTime,
          cause: payload.cause,
          allDay: payload.allDay,
          description: payload.description,
        }

        const unavailability = await unavailabilityService.createUnavailability(unavailabilityData)
        results.push(unavailability)
      } catch (error) {
        logger.error(`Eroare la crearea indisponibilității pentru ${date}`, {
          error,
          date,
          userId: user.id,
          action: 'bulk-create-unavailability',
        })
        errors.push({
          date,
          error: error instanceof Error ? error.message : 'Eroare necunoscută',
        })
      }
    }

    // Revalidare cache pentru pagini relevante
    revalidatePath(APP_ROUTES.STYLIST_UNAVAILABILITY)

    if (errors.length === 0) {
      return {
        success: true,
        message: `${results.length} indisponibilități au fost create cu succes`,
        data: {
          created: results.length,
          total: payload.dates.length,
          results,
        },
      }
    } else if (results.length > 0) {
      return {
        success: true,
        message: `${results.length} din ${payload.dates.length} indisponibilități au fost create cu succes`,
        data: {
          created: results.length,
          total: payload.dates.length,
          results,
          errors,
        },
      }
    } else {
      return {
        success: false,
        error: UNAVAILABILITY_ERROR_MESSAGES.CREATION_FAILED,
        data: { errors },
      }
    }
  } catch (error) {
    logger.error('Eroare la crearea în masă a indisponibilităților', {
      error,
      userId: user.id,
      action: 'bulk-create-unavailability',
    })
    return {
      success: false,
      error: error instanceof Error ? error.message : UNAVAILABILITY_ERROR_MESSAGES.CREATION_FAILED,
    }
  }
}
