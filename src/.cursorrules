# .cursorrules - Reguli Specifice Next.js, TypeScript & Tailwind CSS

## 🚀 Next.js Best Practices

### Structura Proiectului
- Folosește structura App Router pentru directoare
- Plasează componentele în directorul `app` pentru componente specifice rutelor
- Plasează componentele partajate în directorul `components`
- Plasează utilitarele și helper-urile în directorul `lib`
- Folosește lowercase cu cratime pentru directoare (ex: `components/auth-wizard`)

### Componente
- Folosește Server Components în mod implicit
- Marchează explicit componentele client cu 'use client'
- Înfășoară componentele client în Suspense cu fallback
- Folosește dynamic loading pentru componente non-critice
- Implementează error boundaries corespunzătoare
- Plasează conținutul static și interfețele la sfârșitul fișierului

### Performanță
- Optimizează imaginile: Folosește format WebP, size data, lazy loading
- Minimizează folosirea 'useEffect' și 'setState'
- Favorizează Server Components (RSC) unde este posibil
- Folosește dynamic loading pentru componente non-critice
- Implementează strategii de caching corespunzătoare

### Data Fetching
- Folosește Server Components pentru data fetching când este posibil
- Implementează error handling corespunzător pentru data fetching
- Folosește strategii de caching adecvate
- Gestionează loading și error states în mod corespunzător

### Routing
- Folosește convențiile App Router
- Implementează loading și error states corespunzătoare pentru rute
- Folosește rute dinamice în mod corespunzător
- Gestionează rute paralele când este necesar

### Formulare și Validare
- Folosește Zod pentru validarea formularelor
- Implementează validare server-side corespunzătoare
- Gestionează erorile de formular în mod corespunzător
- Afișează loading states în timpul trimiterii formularului

### State Management
- Minimizează state-ul client-side
- Folosește React Context cu moderație
- Preferă server state când este posibil
- Implementează loading states corespunzătoare

## ⚛️ React Best Practices

### Structura Componentelor
- Folosește componente funcționale în locul componentelor class
- Păstrează componentele mici și focusate
- Extrage logica reutilizabilă în custom hooks
- Folosește composition în locul inheritance
- Implementează prop types corespunzătoare cu TypeScript
- Împarte componentele mari în componente mai mici și focusate

### Hooks
- Respectă Rules of Hooks
- Folosește custom hooks pentru logica reutilizabilă
- Păstrează hooks-urile focusate și simple
- Folosește dependency arrays corespunzătoare în useEffect
- Implementează cleanup în useEffect când este necesar
- Evită hooks-uri imbricate

### State Management
- Folosește useState pentru state-ul local al componentei
- Implementează useReducer pentru logica de state complexă
- Folosește Context API pentru state-ul partajat
- Păstrează state-ul cât mai aproape de locul unde este folosit
- Evită prop drilling prin state management corespunzător
- Folosește biblioteci de state management doar când este necesar

### Performanță
- Implementează memoization corespunzătoare (useMemo, useCallback)
- Folosește React.memo pentru componente costisitoare
- Evită re-render-uri inutile
- Implementează lazy loading corespunzător
- Folosește prop-uri key corespunzătoare în liste
- Profilează și optimizează performanța render-ului

### Formulare
- Folosește controlled components pentru input-urile de formular
- Implementează validarea corespunzătoare a formularelor
- Gestionează states-urile de trimitere a formularului în mod corespunzător
- Afișează loading și error states corespunzătoare
- Folosește biblioteci de formulare pentru formulare complexe
- Implementează accesibilitate corespunzătoare pentru formulare

### Error Handling
- Implementează Error Boundaries
- Gestionează erorile async în mod corespunzător
- Afișează mesaje de eroare user-friendly
- Implementează fallback UI corespunzător
- Loghează erorile în mod corespunzător
- Gestionează edge cases cu grație

## 🎨 Tailwind CSS Best Practices

### Configurarea Proiectului
- Folosește configurația Tailwind corespunzătoare
- Configurează extensia theme-ului în mod corespunzător
- Configurează purge configuration corespunzător
- Folosește integrarea de plugin-uri corespunzătoare
- Configurează spacing și breakpoints personalizate
- Configurează paleta de culori corespunzătoare

### Styling Componente
- Folosește utility classes în locul CSS personalizat
- Grupează utilities înrudite cu @apply când este necesar
- Folosește utilities de responsive design corespunzătoare
- Implementează dark mode în mod corespunzător
- Folosește variants de state corespunzătoare
- Păstrează stilurile componentelor consistente

### Layout
- Folosește Flexbox și Grid utilities în mod eficient
- Implementează sistemul de spacing corespunzător
- Folosește container queries când este necesar
- Implementează breakpoints responsive corespunzătoare
- Folosește utilities de padding și margin corespunzătoare
- Implementează utilities de alignment corespunzătoare

### Tipografie
- Folosește utilities de font size corespunzătoare
- Implementează line height corespunzător
- Folosește utilities de font weight corespunzătoare
- Configurează font-uri personalizate în mod corespunzător
- Folosește text alignment corespunzător
- Implementează text decoration corespunzătoare

### Culori
- Folosește denumirea semantică a culorilor
- Implementează contrast de culori corespunzător
- Folosește utilities de opacity în mod eficient
- Configurează culori personalizate în mod corespunzător
- Folosește utilities de gradient corespunzătoare
- Implementează hover states corespunzătoare

### Componente
- Folosește componente shadcn/ui când sunt disponibile
- Extinde componentele în mod corespunzător
- Păstrează variants de componente consistente
- Implementează animații corespunzătoare
- Folosește utilities de transition corespunzătoare
- Păstrează accessibility în minte

## 📘 TypeScript Best Practices

### Sistemul de Tipuri
- Preferă interfaces în locul types pentru definițiile de obiecte
- Folosește type pentru unions, intersections și mapped types
- Evită folosirea `any`, preferă `unknown` pentru tipuri necunoscute
- Folosește configurația strictă TypeScript
- Valorifică utility types built-in din TypeScript
- Folosește generics pentru pattern-uri de tipuri reutilizabile

### Convenții de Denumire
- Folosește PascalCase pentru numele de tipuri și interfaces
- Folosește camelCase pentru variabile și funcții
- Folosește UPPER_CASE pentru constante
- Folosește nume descriptive cu verbe auxiliare (ex: isLoading, hasError)
- Prefixează interfaces pentru React props cu 'Props' (ex: ButtonProps)

### Organizarea Codului
- Păstrează definițiile de tipuri aproape de locul unde sunt folosite
- Exportă tipuri și interfaces din fișiere de tipuri dedicate când sunt partajate
- Folosește barrel exports (index.ts) pentru organizarea exporturilor
- Plasează tipurile partajate într-un director `types`
- Co-localizează props-urile componentelor cu componentele lor

### Funcții
- Folosește tipuri de return explicite pentru funcțiile publice
- Folosește arrow functions pentru callback-uri și metode
- Implementează error handling corespunzător cu tipuri de erori personalizate
- Folosește function overloads pentru scenarii de tipuri complexe
- Preferă async/await în locul Promises

### Best Practices
- Activează strict mode în tsconfig.json
- Folosește readonly pentru proprietăți immutable
- Valorifică discriminated unions pentru type safety
- Folosește type guards pentru type checking la runtime
- Implementează null checking corespunzător
- Evită type assertions cu excepția cazurilor necesare

### Error Handling
- Creează tipuri de erori personalizate pentru erori specifice domeniului
- Folosește tipuri Result pentru operații care pot eșua
- Implementează error boundaries corespunzătoare
- Folosește blocuri try-catch cu catch clauses tipizate
- Gestionează Promise rejections în mod corespunzător

### Pattern-uri
- Folosește Builder pattern pentru crearea de obiecte complexe
- Implementează Repository pattern pentru accesul la date
- Folosește Factory pattern pentru crearea de obiecte
- Valorifică dependency injection
- Folosește Module pattern pentru encapsulation

---

**Principii Fundamentale**: Urmează aceste reguli pentru a asigura cod consistent, performant și mentenabil în cadrul proiectului salon management platform.
